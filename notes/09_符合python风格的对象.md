### 符合Python风格的对象

绝对不要使用两个前导下划线，这是很烦人的自私行为。

每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方法。

`repr()`：以便于开发者理解的方式返回对象的字符串表示形式。

`str()`：以便于用户理解的方式返回对象的字符串表示形式。

我们要实现`__repr__`和`__str__`特殊方法，为`repr()`和`str()`提供支持。

为了给对象提供其他的表示形式，还会用到另外两个特殊方法：`__bytes__`和`__format__`。`__bytes__`方法与`__str__`方法类似：`bytes()`函数调用它获取对象的字节序列表示形式。而`__format__`方法会被内置的`format()`函数和`str.format()`方法调用，使用特殊的格式代码显示对象的字符串表示形式。

在Python3中，`__repr__`、`__str__`和`__format__`都必须返回Unicode字符串（str类型）。只有`__bytes__`方法应该返回字节序列（bytes类型）。

#### `classmethod`与`staticmethod`

`classmethod`用法：定义操作类，而不是操作实例的方法。`classmethod`改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。其最常见的用途是定义备选构造方法。

`staticmethod`装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，**静态方法就是普通函数**，只是碰巧在类的定义体中，而不是在模块层定义。

> `classmethod`装饰器非常有用，但是还没遇到过不得不用`staticmethod`的情况。如果想定义不想与类交互的函数，那么在模块中定义就好了。有时，函数虽然不处理类，但是函数的功能与类紧密相关，因此想把它放在近处。即便如此，在同一模块中的类前面与后面定义函数也就行了。

#### 格式化显示

内置的`format()`函数和`str.format()`方法把各个类型的格式化方式委托给相应的`.__format__(format_spec)`方法。`format_spec`是格式说明符。

- `format(my_obj, format_spec)`的第二个参数，或者

- `str.format()`方法的格式字符串，`{}`里代换字段中冒号后面的部分。

如果类没有定义`__format__`方法，从`object`继承的方法会返回`str(my_object)`。

使用两个前导线（尾部没有下划线，或者有一个下划线），把属性标记为私有的。

`@property`装饰器把读值方法标记为特性。

要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性，只需正确地实现`__hash__`和`__eq__`方法即可。但是，实例的散列值绝不应该变化。

#### Python的私有属性和“受保护的”属性

Python不能像Java那样使用`private`修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖“私有”属性。

举个例子，有人编写了一个名为Dog的类，这个类的内部用到了`mood`实例属性，但是没有将其开放。现在，你创建了Dog类的子类：Beagle。如果你在毫不知情的情况下又创建了名为`mood`的实例属性，那么在继承的方法中就会把Dog类的`mood`属性覆盖掉。

为了避免这种情况，如果以`__mood`的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python会把属性名存入实例的`__dict__`属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，`__mood`会变成`_Dog__mood`；对于Beagle类来说，会变成`_Beagle__mood`。这个语言特性叫名称改写（name mangling）。

以上内容可预见：对于类中的私有函数的访问，`obj._classname__pname`。

当然也有类似`_mood`定义私有属性的方式（一个前导线）。这样做，python解释器不会对使用单个下划线的属性名做特殊处理。

`__slots__`属性能够显著节省内存。
