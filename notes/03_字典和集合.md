### 字典和集合

`dict`类型不但在各种程序里广泛使用，它也是Python 语言的基石。

Python 对它的实现做了高度优化，而散列表则是字典类型性能出众的根本原因。

集合`set`的实现其实也依赖于散列表。接下来会对散列表进行介绍。

对于`可散列`的定义：如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的。

原子不可变数据类型（str、bytes和数值类型）都是可散列类型，`frozenset`也是可散列类型。元组的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。

所有的映射类型在处理找不到的键的时候，都会牵扯到`__missing__`方法。

`__contains__`方法（`in`会调用它）

字典中`d.setdefault(k, [default])`：若字典中有键k，则把它对应的值设为`default`，然后返回这个值；若无，则`d[k] = default`，然后返回`default`。

用`d.setdefault`来替代`d.get`的使用环境。

集合（`set`，`frozenset`）的本质是许多唯一对象的聚集。

集合中的元素必须是可散列的，`set`类型本身是不可散列的，但是`frozenset`可以。

除了保证唯一性，集合还实现了很多基础的中缀运算符。给定两个集合a和b，`a | b`返回的是它们的合集，`a & b`得到的是交集，而`a - b`得到的是差集。

除空集外，集合的字面量——{1}、{1, 2}，等等——看起来跟它的数学形式一模一样。如果是空集，那么必须写成`set()`的形式。

在Python3 中，除了空集，集合的字符串表示形式总是以{...}的形式出现。

构造`frozenset`语法：`frozenset(range(10))`

#### `dict`和`set`的背后

想要理解python 里字典和集合类型的长处和弱点，它们背后的散列表是绕不开的一环。

`d.fromkeys(it, [initial])`:将迭代器it里的元素设置为映射里的键，如果有initial参数，就把它作为这些键对应的值（默认是None）。

散列表其实是一个稀疏数组（总是有空白元素的数组称为稀疏数组）。

如果要把一个对象放入散列表，那么首先要计算这个元素键的散列值。`hash()`。

字典在内存上的开销巨大。

由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率底下。

`dict`的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无视数据量大小的快速访问——只要字典能被装在内存里。

键的次序取决于添加顺序

往字典里添加新键可能会改变已有键的顺序。

不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分为两步来进行：首先对字典进行迭代，以得出需要添加的内容，把这些内容放在一个新字典里：迭代结束之后再对原有字典进行更新。

简单而正确。
