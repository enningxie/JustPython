### 对象引用、可变性和垃圾回收

元组是不可变的，但是其中的值可以改变。

变量不是盒子。

为了理解Python中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。

因为变量只不过是标注，所以无法阻止为对象贴上多个标注。贴的多个标注，就是别名。

每个对象都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。`is`运算符比较两个对象的标识；`id()`函数返回对象标识的整数表示（对象的内存地址），ID一定是唯一的数值标注，而且在对象的生命周期中绝不会变。

其实，编程中很少使用`id()`函数。标识最常用`is`运算符检查，而不是直接比较ID。`==`运算符比较两个对象的值（对象中保存的数据），而`is`比较对象的标识。

通常，我们比较关注的是值，而不是标识，因此Python代码中`==`出现的频率比`is`高。

然而，在变量和单例值之间比较时，应该使用`is`。目前，最常使用`is`检查变量绑定的值是不是`None`。：

```Python
x is None
```

否定的正确写法是：

```Python
x is not None
```

`is`运算符比`==`速度快，因为它不能重载。

元组与多数Python集合（列表、字典、集，等等）一样，保存的是对象的引用。如果引用的元素是可变的，即便元组本身是不可变的，元素依然可变。也就是说，元组的不可变性其实是指`tuple`数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

> 而`str`、`bytes`和`array.array`等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字）

元组的值会随着引用的可变对象的变化而变。元组中不可变的是元素的标识。

#### 深复制和浅复制

浅复制没什么问题，但有时我们需要的是深复制（即副本不共享内部对象的引用）。`copy`模块提供的`deepcopy`和`copy`函数能为任意对象做深复制和浅复制。

不要使用可变类型作为参数的默认值。

如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。

除非这个方法确实是想修改参数传入的对象，否则在类中直接把参数赋值给实例变量之前一定要三思，因为这样会为参数对象创建别名。如果不确定，那就是创建副本。这样客户会少些麻烦。

#### `del`和垃圾回收

对象绝对不会自行销毁；然而，无法得到对象时，可能会被当做垃圾回收。

`del`语句删除名称，而不是对象。

`del`命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。

重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。即如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁。

正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但是，有时需要引用对象，而不让对象存在的时间超过所需时间。这经常用在缓存中。

弱引用不会增加对象的引用数量。引用的目标对象称为所指对象。弱引用不会妨碍所指对象被当做垃圾回收。

弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。

弱引用是可调用的对象，返回的是被引用的对象；如果所指对象不存在了。返回`None`。

每个Python对象都有标识、类型和值。只有对象的值会不时变化。

变量保存的是引用。

- 简单的赋值不创建副本

- 对`+=`或`*=`所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。

- 为现有变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当做垃圾回收。

- 函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象，这一行为无法避免，除非在本地创建副本，或使用不可变对象（如，传入元组，而不传入列表）。

- 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就改变了，这会影响以后使用默认值的调用。

Python中，`==`运算符比较对象的值，而`is`比较引用。此外，pyhton支持重载运算符，`==`能正确处理标准库中的所有对象，包括`None`。
