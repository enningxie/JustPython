### 函数装饰器和闭包

函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。

如果你想自己实现函数装饰器，那就必须了解闭包的方方面面，因此也就需要知道`nonlocal`。

除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。

装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。

装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行。

函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。

装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。

大多数装饰器会在内部定义一个函数，然后将其返回。

多数装饰器会修改被装饰的函数。通常，它们会定义一个内部函数，然后将其返回，替换被装饰的函数。

python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。

使用关键字`global`将指定变量当成全局变量。

在博客圈，人们有时会把闭包和匿名函数弄混。其实闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。

闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

注意只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。

`nolocal`关键字声明，它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为`nolocal`声明的变量赋予新值，闭包中保存的绑定会更新。

#### 实现一个简单的装饰器

首先定义一个装饰器，它会在每次调用被装饰的函数时计时，然后把经过的时间、传入的参数和调用的结果打印出来。

```Python
import time

def clock(func):
  def clocked(*args):
    t0 = time.perf_counter()
    result = func(*args)
    elapsed = time.perf_counter() - t0
    name = func.__name__
    arg_str = ','.join(repr(arg) for arg in args)
    print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
    return result
  return clocked
```

使用clock装饰器
